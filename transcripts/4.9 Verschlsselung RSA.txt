 Im folgenden Abschnitt reden wir über eine Anwendung von Rechnen mit Restklassen, nämlich reden wir über Public Key Kryptographie Verfahren. Es geht also darum, eine geheime Nachricht irgendwie zu unkenntlich zu machen oder zu verschlüsseln, sodass sie nicht von Dritten gelesen werden kann, aber von einer befugten Person am anderen Ende der Leitung wiederhergestellt werden kann, bzw. entschlüsselt werden kann. Dazu wollte ich erst noch kurz darauf hinweisen, dass wir Nachrichten einfach als Sequenzen von Zahlen ansehen. Also sobald wir eine Zahl geheim verschicken können, gehen wir davon aus, dass wir Nachrichten geheim verschicken können. Erstmal reden wir über symmetrische Verschlüsselung, also Private Key Verschlüsselung, in Vorbereitung auf die Public Key Verschlüsselung danach. Hier gibt es einen globalen Schlüssel, der vom Sender und vom Empfänger gekannt wird. Beide kennen diesen Schlüssel k hier, das ist halt irgendeine Zahl. Es gibt die Nachricht, auf Englisch plaintext, deswegen das p hier. Mit dem Schlüssel zusammen können wir den Cyphertext, also die verschlüsselte Botschaft, berechnen. Zum Beispiel indem wir einfach die Nachricht mit dem Schlüssel addieren und das ganze Modul 26 rechnen. Was da rauskommt ist einer von 26 Werten, den wir als Buchstaben interpretieren können. Je nachdem wie der Schlüssel aussieht, kommt ein großes Cauderwelsch raus, also hat nichts mehr mit der ursprünglichen Nachricht zu tun. Weil der Empfänger auch den Schlüssel hat, der Schlüssel ist beiden bekannt, das ist ein Schlüssel, der private Schlüssel. Weil der Empfänger den Schlüssel auch hat, kann er vom Cyphertext C den Schlüssel einfach abziehen und kommt dann wieder auf die ursprüngliche Nachricht p. Bzw. p' hier, aber p' ist gleich p. Er bekommt also wieder den Buchstaben raus, der hier mit dem Schlüssel verschlüsselt wurde. Also zum Beispiel wenn wir den Buchstaben A verschicken wollen, das entspricht der Zahl 0, wir sortieren die alphabetstechnisch. Unser Schlüssel hier ist einfach 3, das heißt wir würden auf das A, das ist unser p, dann wäre unser C genau 3, also sprich was man sehen würde, was über die Leitung öffentlich geschickt wird. C, C, D, richtig. Das wäre ein D und solange ich den Schlüssel hier nicht kenne, habe ich keine Chance das A aus dem D zu rekonstruieren. Der Empfänger kann aber dann wieder den Schlüssel abziehen und kommt wieder 0 und weiß dann, okay, es ist ein A, was da versendet wurde. Natürlich ist es irgendwie unsicher, da so kurze Schlüssel zu benutzen. Das heißt man kann das irgendwie attackieren mit dem Wissen, dass der Buchstabe E meinetwegen am häufigsten vorkommt in solchen Nachrichten. Dann kann man so eine Häufigkeitstabelle aufstellen und damit den wahrscheinlichsten Buchstaben aus der ganzen Welt herausfinden. Beziehungsweise bei diesem einstelligen Schlüssel kann man auch einfach alle Schlüssel ausprobieren und gucken unter welchem Schlüssel ergibt diese Nachricht, die ich hier versendet habe, tatsächlich Sinn. Aus diesem Grunde ist es eigentlich sehr einfach, dass man so eine Nachricht übersetzt. Wenn man den Schlüssel hat, dann kann man die Nachricht übersetzen. Beziehungsweise bei diesem einstelligen Schlüssel kann man auch einfach alle Schlüssel ausprobieren und gucken unter welchem Schlüssel ergibt diese Nachricht, die ich hier versendet habe, tatsächlich Sinn. Aus diesem Grunde werden Nachrichten häufig einfach in Blöcke aufgeteilt. Also, das ist nicht sehr unbefremdend, aber alle meinenwegen haben so einen 4er Block da drauf und ihr Schlüssel besteht jetzt aus 4 Zahlen. Meinetwegen 3, 0, 12, 5. Und dann würden sie diesen Schlüssel jeweils auf alle diese Buchstaben drauf addieren. Buchstaben und Zahlen nennen das selbe. So, da käme dann sowas raus wie, na hier bleibt unser D wie zuvor, das L bleibt stehen, weil hier eine 0 ist. Ich glaube, L plus 12 wird zu X und E plus 6 wird glaube ich zu J. Das heißt, das wäre ihre Nachricht, das wäre ihr Cypher-Text, der über die Leitung geht, den sich jeder angucken kann. Und dann würde man halt wieder mit diesem Schlüssel hier oben, also das sind 4 Zahlen in diesem Fall, jeweils die einzelnen Buchstaben hier bearbeiten und käme wieder auf das ursprüngliche Wort. Okay, hier brauchen wir aber als große Voraussetzung, als große Annahme, haben wir getätigt, dass der Sender und der Empfänger einen gemeinsamen geheimen Schlüssel haben. Aber wenn ich mit jemandem kommunizieren möchte, den ich noch nie zuvor getroffen habe, dann können wir ja nicht irgendwie ein gemeinsames Geheimnis haben. Also müssen wir ein gemeinsames Geheimnis irgendwie ausmachen. Und es ist nicht ganz klar, wie das passieren kann. Insbesondere, wenn sämtliche Kommunikation mit der anderen Person über einen öffentlichen Kanal stattfindet. Also Sie können sich das vorstellen wie, weiß nicht, zwei Menschen, die sich noch nie vorher gesehen haben, kommen irgendwie in einen Raum und unterhalten sich öffentlich. Und da sitzen noch andere Leute in dem Raum drin, die wollen halt das Geheimnis erfahren. Und nachdem die beiden Menschen gesprochen haben, haben sie ein gemeinsames Geheimnis, aber niemand sonst im Raum weiß das. Und das ist schon irgendwie abgefahren. Weil ja irgendwie alles, was die beiden miteinander gesprochen haben, von jedem anderen auch mitgehört wurde. Und das wird ermöglicht durch sogenannte asymmetrische Verschlüsselung oder Public Key Cryptography. Hier ist die Idee, dass jeder einen öffentlichen und einen privaten Schlüssel hat. Und der öffentliche Schlüssel nur zum Verschlüsseln benutzt wird und der private Schlüssel nur zum Entschlüsseln benutzt wird. Das heißt insbesondere jeder kann Nachrichten an sie verschlüsseln. Aber niemand kann eine so verschlüsselte Nachricht wieder entschlüsseln. Außer sie selber. Also nochmal, die Voraussetzung ist, dass jeder einen öffentlichen Schlüssel preisgibt und einen geheimen privaten Schlüssel für sich behält. Unter anderem ist RSA eine mögliche Implementierung davon. Ein ganz bekanntes Crypto-Verfahren benannt nach den Autoren. Die da heißen Rebist, Shamir und Edelman. Und damit beschäftigen wir uns jetzt ein bisschen mit dem RSA-System. Und zwar, zur Vorbereitung muss jeder, der am Verschlüsselungssystem teilnehmen möchte, sich zwei große Primzahlen wählen. Und hier ist ein Ausrufungszeichen. Je größer diese Primzahlen, desto sicherer ist das Verfahren. Weil es darauf basiert, dass Angreifer diese Primzahlen berechnen müssen. Und je größer die werden, desto schwieriger ist es, sie zu berechnen. Jeder Teilnehmer hat diese zwei großen Primzahlen, P und Q. Und aus denen berechnen wir jetzt einen öffentlichen und einen privaten Schlüssel. Und zwar, für den öffentlichen Schlüssel berechnen wir uns hier so ein E. Mit GGT von E und P-1Q-1 ist gleich 1. Also sprich, E ist teilerfremd zu dem Produkt aus den beiden Vorgängern der Primzahlen. Da können sich zum Beispiel neue Primzahlen wählen. Primzahlen sind immer teilerfremd zu anderen Zahlen, die nicht durch die Primzahl teilbar sind. Also dieses E lässt sich schon irgendwie finden. Das ist nicht so schwierig. Und daraus, aus diesen drei Zahlen P, Q und E, basteln wir jetzt einen öffentlichen Schlüssel. Den malen wir grün. Der öffentliche Schlüssel, das ist diese Zahl E zusammen mit der Zahl N. Was ist das? Das ist einfach das Produkt der beiden Primzahlen. Und der ist öffentlich. Das heißt, sie geben das Produkt ihrer Primzahlen raus. Das heißt, sobald jemand in der Lage ist, dieses N hier hinten, was allgemein bekannt ist, zu faktorisieren, dann kann derjenige diese beiden Primzahlen P und Q wiederherstellen. Das ist aber ihr Geheimnis, diese beiden Primzahlen. Deswegen wäre es schlecht, wenn das N hier schnell faktorisierbar wäre. Also damit würde alles zusammenbrechen. Aber wie gesagt, wir kennen aktuell kein Verfahren, mit dem man große Zahlen schnell faktorisieren kann. Und insbesondere, wenn ihre zwei Primzahlen P und Q hier groß sind, dann ist das N erst recht eine große Zahl. Und darauf basiert die Robustheit des Verfahrens. Ihr privater Schlüssel besteht jetzt aus einem Wert d und N auch. Wobei d so ist, dass e mal d kongruent zu 1 Modulo dem Produkt der beiden Vorgänger der Primzahlen ist. Insbesondere können Sie das d berechnen mit dem erweiterten Euclid'schen Algorithmus. Wenn Sie hier die Zahlen e und das Produkt der Vorgänger der Primzahlen in den erweiterten Euclid'schen Algorithmus reinstecken, dann bekommen Sie da Zahlen s und t raus, die Besu-Koeffizienten. Sodass d mal s plus t mal d minus 1 q minus 1 ist gleich 1. Und dieses s hier ist nichts anderes als das d, was wir wollen. Denn, können wir uns überlegen, d mal d minus 1 ist minus t mal d minus 1 q minus 1. Da habe ich einfach nur das rüber geschaufelt. Und das heißt aber, dass d mal d minus 1 ist ein Vielfaches von p minus 1 mal q minus 1. Also mit anderen Worten, d minus 1 mal q minus 1 teilt d mal d minus 1. Und das ist genau die Definition von d mal d kongruent 1 Modulo p minus 1 mal q minus 1. Jetzt haben wir also unseren öffentlichen und privaten Schlüssel vorbereitet. Jetzt können wir teilnehmen am RSA-Verfahren. Und sagen wir mal, irgendjemand möchte uns eine Nachricht m schicken. M und Nachrichten, wie gesagt, sind Zahlen. Jemand möchte uns eine Zahl schicken. Und genau, wir sind jetzt der Teilnehmer A. Was man jetzt macht, um die Nachricht an uns zu verschlüsseln, ist die sogenannte Cypher oder den Cypher-Text c zu berechnen, als die Nachricht, also die Nachricht hoch e. E ist hier der öffentliche Schlüssel. Modulo n. Das kann man halt einfach berechnen. Und das ist die neue Zahl c. Und die kann man jetzt über die Leitung schicken. Die können alle gerne erfahren, weil nur wir die wieder entschlüsseln können. Zum Beispiel, sagen wir mal, wir haben uns die Primzahlen 43 und 59 gewählt. Und unser e ist 13. Das ist teilerfremd zu dem Produkt der Vorgänger. Produkt der Vorgänger hier, 42 mal 58. Dazu ist 13 teilerfremd, weil das hier hinten kein Vielfaches von 13 ist. Und 13 ist eine Primzahl. Was man jetzt berechnet, um uns diese Nachricht m hier, 18, 19 zu schicken, ist einfach 18, 19 hoch 13 und dann Modulo n, wobei n das Produkt unserer beiden gewählten Primzahlen ist. Und da kommt jetzt diese effiziente Exponentierung ins Spiel. Sie erinnern sich, dass man hier diesen Exponenten als binäre Zahl darstellen kann und dann man durch Quadrierung und Restbildung die Zahlen, die man hier handhaben muss, klein halten kann, obwohl halt 18, 19 hoch 13 eine enorm große Zahl ist. Wir können halt immer in Zahlen Modulo n, also Modulo 2537 rechnen. Und daraus kommt dann am Ende hier die verschlüsselte Nachricht 2081. Und entschlüsseln tut man diese Nachricht c dann, indem man c mit dem privaten Schlüssel d exponenziert und den Rest nach Division durch n berechnet. Das ist dann hier die entschlüsselte Nachricht m' und in der Hoffnung, dass m dann gleich m' ist, aber das zeigen wir dann. In unserem konkreten Beispiel hier erfahren wir, dass mit dem erweiterten Euclidischen Algorithmus kriegen wir hier aus e und den beiden Primzahlen kriegen wir unseren geheimen Schlüssel d, in diesem Fall 937 halt. Das heißt, was wir nun machen müssen, ist die verschlüsselte Nachricht, die wir hier übertragen haben, also 2081, rechnen hoch 937, unserem geheimen Schlüssel, und dann den Rest bilden bei Division durch 2537, also unser n. Und da kommt dann tatsächlich wieder 1819 raus, was die ursprüngliche Nachricht war. Also wir kriegen wieder unsere ursprüngliche Nachricht raus. Und da wir aber die Einzigen sind, die den geheimen Schlüssel, den roten Schlüssel hier haben, können nur wir die Nachricht entschlüsseln, obwohl jeder Nachrichten an uns verschlüsseln kann. Das Ding ist, warum es funktioniert, bzw. warum niemand sonst die ursprüngliche Nachricht rekonstruieren kann, ist, obwohl sie hier dieses e kennen, also ich hab's vergessen grün zu setzen, also den Exponenten, mit dem die ursprüngliche Nachricht exponenziert wurde, und den Modul und das, was rauskommt am Ende. Das ist alles dem Angreifer bekannt, aber trotzdem schafft es damit nicht, diese Basis hier auszurechnen. Weil man Exponentierung unter Resten, also von Restklassen, nicht leicht rückgängig machen kann. Hier spricht man vom diskreten Logarithmus. Ein normaler Logarithmus ist die Umkehroperation zur Exponentierung, und Exponentierung in Restklassen, die Umkehroperation nennt man diskreten Logarithmus, und der lässt sich halt nicht leicht berechnen. Es sei denn, man hat halt diesen Hinweis, also der geheime Schlüssel ist der Hinweis, den man braucht, um Rückschlüsse treffen zu können auf die originalen Nachrichten. Schön und gut, dass das funktioniert hat in unserem Beispiel, aber wir wollen gerne zeigen, dass das allgemein funktioniert. Also dass die geheime Nachricht, hoch E, das ist unser Ciphertext, den alle kennen, hoch D, das ist unser M. Kongruent M, Modul N reicht uns aus. Das heißt zwar, dass alle Nachrichten kleiner sein müssen als N, aber das ist ja auch kein Problem, wir müssen sie nur in Blöcke zerhacken. So klein sind die Blöcke auch gar nicht, sie erinnern sich, dass wir zwei große Primzahlen genommen haben, die wir dann reduziert haben, und das war unser N. Wir können also davon ausgehen, dass unsere Nachricht hier kleiner ist als N. Das heißt, wenn das, was wir hier rausgerechnet haben, Kongruent ist zu M Modul N, dann kriegen wir halt auch M raus. Um das zu zeigen, zeigen wir zwei Kongruenzen, nämlich das Ergebnis unserer Berechnung, Kongruent M ist Modul P und Kongruent M Modul Q. Dann sehen Sie vielleicht hier schon, was wir machen werden, dann können wir nämlich hinterher den chinesischen Restsatz anwerfen und kriegen, dass das auch Kongruent ist zu M Modul P mal Q. Zunächst erinnern wir uns dran, dass wir D so gewählt haben, dass dieses Produkt hier P-1 mal Q-1 die Differenz von E mal D-1 teilt. Das sagt das hier oben aus. Das heißt, nach Definition von Teilbarkeit heißt es, es gibt so ein x hier, sodass wenn ich das an P-1 mal Q-1 ran multipliziere, dann kommt da E mal D-1 raus. Ich kann die 1 halt rüberziehen, also ist E mal D ist 1 plus x mal diesen Produkt der Vorgänge. Kurze Bemerkung vielleicht, dieses x war genau der zweite BESU-Koeffizient, so irgendwie dieses t, was wir vorhin hatten, beziehungsweise minus t. Dann können wir eine Fallunterscheidung machen, in die Fälle, ob die Primzahl P jetzt die Nachricht teilt oder nicht, darüber haben wir keine Kontrolle. Das könnte passieren, aber wenn es passiert, heißt es, dass nach Division durch P lässt M den Rest 0, also M konkurrent 0. Das heißt, wenn ich jetzt hier 0 exponentiere mit E mal D, dann kommt nur immer wieder 0 raus. Das heißt, M hoch irgendein Exponent ist auf jeden Fall konkurrent 0 im Modulo P. Außer vielleicht, wenn der Exponent 0 ist, aber der Exponent kann nicht 0 sein, weil, naja, hier ist wir haben E mal D ist 1 plus irgendwas und dieses irgendwas hier ist bestimmt nicht minus 1, weil P und Q sehr große Primzahlen waren. Okay, bringt uns zum zweiten Fall, das P M nicht teilt. Dann lässt sich aber jetzt der kleine Satz von Fermat anwenden. Wir haben eine Primzahl, die unser A hier, also das war im kleinen Satz von Fermat war das hier das A. Da das nicht geteilt wird von P, gilt also das war halt wie gesagt A hoch P minus 1, Modulo P und da unser A jetzt hier M heißt, haben wir das M hoch P minus 1, Konkurrent 1 ist Modulo P. Dann können wir jetzt aber schreiben M hoch E D können wir mit dieser Gleichung schreiben als M hoch 1 plus x mal P minus 1 mal Q minus 1 und wir wissen, also das können wir auch schreiben als M mal M hoch P minus 1 hoch x mal Q minus 1 Das ist einfach das Plus hier wird halt zu einem Mal und dann hier diese Multiplikation können wir so klammern. So jetzt ist aber M hoch P minus 1 ist gleich 1 Modulo P, also das ist Konkurrent zu M mal 1 hoch x mal Q minus 1 Modulo P Also 1 hoch irgendwas bleibt immer 1, das heißt das ist Konkurrent zu M Modulo P Also hier ist die Stelle, wo wir den kleinen Fermat benutzt haben Okay, das heißt wir haben jetzt den Fall A abgehandelt. Entweder P teilt M dann haben wir M hoch E D ist Konkurrent M Modulo P oder P teilt nicht M, dann haben wir trotzdem M hoch E D ist Konkurrent M Modulo P. Und für den Fall B läuft das jetzt komplett analog, nur dass wir halt statt P hier jeweils Q haben. Aber ansonsten läuft das genau gleich Wir haben also festgestellt dass M hoch E D hier und hier haben wir das festgestellt dass M hoch E D dieses Konkurrentsystem löst Also x Konkurrent M Modulo P und M Modulo Q Und außerdem haben wir, dass das GGT von P und Q gleich 1 ist, also die sind teilerfremd Da muss man noch dazu sagen, dass bitte P ungleich Q sein soll Aber dann sind die halt teilerfremd Und dann sagt uns damit der chinesische Restsatz dass diese Lösung, die wir berechnet haben, M hoch E D eindeutig ist zwischen 0 und dem Produkt der Moduli Also mit anderen Worten Wir wissen, dass x plus irgendwie für jedes i, i mal n löst auch dieses Konkurrentsystem hin Also mit anderen Worten M E D, diese Lösung, ist konkurrent zu M Modulo, dem Produkt der zwei Moduli in unserem Konkurrentsystem Das Produkt der zwei Moduli im Konkurrentsystem ist genau gleich in N Zusammenfassend, wir suchen uns vorbereitend zwei Primzahlen P und Q und hier sollte ich es auch nochmal hinschreiben, die sind ungleich und halt verdammt große Primzahlen Dann bilden wir das Produkt N aus den beiden und geben es raus öffentlich Dann suchen wir uns irgendwie einen E raus das teilerfremd ist zum Produkt der Vorgänger von P und Q, das kann zum Beispiel eine weitere Primzahl sein die auch relativ groß ist und die Zahl geben wir auch öffentlich raus und dann berechnen wir noch ein D mit Hilfe des erweiterten Euclidischen Algorithmus Das ist unser Geheimerschlüssel, den behalten wir für uns Das heißt, wir können, weil wir Kenntnis von E und Q haben, mittels des Erweiterten Euclidischen Algorithmus schnell das D finden für das das gilt. Wenn wir die Primzahlen P und Q allerdings nicht haben, dann ist aktuell kein Verfahren bekannt, das den Geheimerschlüssel schnell bestimmt. Und wenn die Zahlen groß genug gewählt werden, dann habe ich auch keine Chance mit ausprobieren irgendwie den Geheimerschlüssel rauszufinden Das heißt, wichtig, die Sicherheit vom RSA Prinzip beruht also darauf, dass wir nicht wissen, wie man effizient faktorisiert. Also die Berechnungsschwere des Faktorisierens Es ist nicht bewiesen, dass das Problem lange dauern, also dass man viel Zeit investieren muss, um das zu lösen Das heißt, es könnte sein, dass in der Zukunft irgendwann jemand einen Algorithmus findet, mit dem man schnell faktorisieren kann und dann bricht alles, naja, was heißt alles, aber das RSA System bricht dann zusammen Also beruht auf Berechnungsschwere des Faktorisierens und diskreter Logarithmus Weil wenn sie diskreten Logarithmus berechnen könnten, dann könnten sie auch aus dem öffentlichen Schlüssel und einer abgefangenen Nachricht die ursprüngliche Nachricht berechnen